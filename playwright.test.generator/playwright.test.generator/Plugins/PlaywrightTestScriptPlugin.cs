using System.ComponentModel;
using System.Diagnostics;
using System.Net.Http;
using System.Security.Cryptography.X509Certificates;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.SemanticKernel;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace playwright.test.generator.Plugins;


public class PlaywrightTestScriptPlugin
{

    public const string KernelFunctionName="evaluate_playwright_test_script";

    [KernelFunction(KernelFunctionName)]
    [Description("Returns the output of the provided playwright test script generated by the assistant. Assistant MUST call this function only after all scenario steps have been executed. If the script runs without errors and all test pass, assistant must reply with these exact words 'TEST OK'. If the script has still errors after the assistant has tried to fox it up to the maximum amount of time, , assistant must reply with these exact words 'TEST KO'")]
    public async Task<string> EvaluatePlaywrightTestScript(
        [Description("the assistant generated playwright test script")] string playWrightScript)
    {
        try {
               
            var fileName = Path.GetFileName( Path.ChangeExtension(Path.GetTempFileName(), "spec.ts"));
            var fp = Path.GetFullPath(Path.Combine(Directory.GetCurrentDirectory(), fileName));
            await File.WriteAllTextAsync(fp, playWrightScript);
            var ret = await RunCommand($"npx.cmd playwright test {fileName} --reporter=list");
            
            return $"exit code {ret.ExitCode} Output: {ret.stdOut} Error: {ret.stdError} ";

        }
        catch     (Exception ex)
        {
            return $"An error occurred while executing the Playwright test script: {ex.ToString()}";
        }   


    }

    static async Task<(int ExitCode, string stdOut,string stdError)> RunCommand(string commandToRun)
    {
        var workingDirectory = Directory.GetCurrentDirectory();

        var processStartInfo = new ProcessStartInfo()
        {
            FileName = "cmd",
            RedirectStandardOutput = true,
            RedirectStandardInput = true,
            RedirectStandardError = true,
            WorkingDirectory = workingDirectory
        };

        var process = Process.Start(processStartInfo);

        Task<string> outputTask = process.StandardOutput.ReadToEndAsync();
        Task<string> errorTask = process.StandardError.ReadToEndAsync();

        if (process == null)
        {
            throw new Exception("Process should not be null.");
        }

        process.StandardInput.WriteLine($"{commandToRun} & exit");
        await Task.WhenAll(outputTask, errorTask);
        await process.WaitForExitAsync();

        Console.WriteLine($"out {outputTask.Result} error: {errorTask.Result}");
        return (process.ExitCode, outputTask.Result, errorTask.Result); // Return the exit code of the process 
    }

}
